"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingleTransactionWrapper = void 0;
const web3_js_1 = require("@solana/web3.js");
const ConnectionManager_1 = require("./ConnectionManager");
/**
 * Represents a wrapper class for a single transaction.
 */
class SingleTransactionWrapper {
    constructor() {
        this._connections = [];
        this._shouldAddBlockhash = true;
        this._shouldAddFeePayer = true;
        this._shouldSign = true;
        this._shouldConfirm = true;
    }
    create() { return new SingleTransactionWrapper(); }
    setTransaction(transaction) {
        this._transaction = transaction;
        return this;
    }
    setConnections(connections) {
        this._connections = connections;
        return this;
    }
    addConnection(connection, config) {
        if (connection instanceof web3_js_1.Connection) {
            this._connections.push(connection);
        }
        else if (connection instanceof ConnectionManager_1.ConnectionManager) {
            this._connections.push(connection.connSync({}));
        }
        else if (typeof connection === 'string') {
            this._connections.push(new web3_js_1.Connection(connection, config));
        }
        else {
            throw new Error('Invalid connection');
        }
        return this;
    }
    setShouldAddBlockhash(shouldAddBlockhash) {
        this._shouldAddBlockhash = shouldAddBlockhash;
        return this;
    }
    setShouldAddFeePayer(shouldAddFeePayer) {
        this._shouldAddFeePayer = shouldAddFeePayer;
        return this;
    }
    setShouldSign(shouldSign) {
        this._shouldSign = shouldSign;
        return this;
    }
    setShouldConfirm(shouldConfirm) {
        this._shouldConfirm = shouldConfirm;
        return this;
    }
    setBlockhash(blockhash) {
        if (this._transaction instanceof web3_js_1.Transaction) {
            this._transaction.recentBlockhash = blockhash;
        }
        else if (this._transaction instanceof web3_js_1.VersionedTransaction) {
            this._transaction.message.recentBlockhash = blockhash;
        }
        else if (this._transaction instanceof Buffer) {
            throw new Error('Cannot set blockhash for already serialized transaction');
        }
        else {
            throw new Error('Invalid transaction type');
        }
        return this;
    }
    setFeePayer(feePayer) {
        if (this._transaction instanceof web3_js_1.Transaction) {
            this._transaction.feePayer = feePayer;
        }
        else if (this._transaction instanceof web3_js_1.VersionedTransaction || this._transaction instanceof Buffer) {
            throw new Error('Cannot set fee payer for VersionedTransaction or serialized transaction');
        }
        else {
            throw new Error('Invalid transaction type');
        }
        return this;
    }
    send({ wallet, signer, signers, confirmationCommitment, blockhashOverride, feePayerOverride, shouldConfirmOverride, shouldRaceSend, skipPreflight }) {
        return __awaiter(this, void 0, void 0, function* () {
            // validate transaction has been set/has instructions
            if (this._transaction === undefined) {
                throw new Error('Transaction is undefined');
            }
            if (this._transaction instanceof web3_js_1.Transaction && this._transaction.instructions.length === 0) {
                throw new Error('Transaction has no instructions');
            }
            if (this._transaction instanceof web3_js_1.VersionedTransaction && this._transaction.message.compiledInstructions.length === 0) {
                throw new Error('Transaction has no instructions');
            }
            // validate at least one connection has been set
            if (this._connections.length === 0) {
                throw new Error('No connections provided');
            }
            // get blockhash if needed
            let blockhash;
            if (this._shouldAddBlockhash || blockhashOverride !== undefined) {
                blockhash = blockhashOverride || (yield this._connections[0].getLatestBlockhash({
                    commitment: confirmationCommitment || 'max'
                })).blockhash;
            }
            // add blockhash to transaction
            if (this._transaction instanceof web3_js_1.Transaction && this._shouldAddBlockhash) {
                this._transaction.recentBlockhash = blockhash;
            }
            else if (this._transaction instanceof web3_js_1.VersionedTransaction && this._shouldAddBlockhash) {
                this._transaction.message.recentBlockhash = blockhash;
            }
            // add fee payer to transaction if needed
            if (this._transaction instanceof web3_js_1.Transaction && this._shouldAddFeePayer && feePayerOverride !== undefined) {
                this._transaction.feePayer = feePayerOverride;
            }
            // sign transaction if needed
            if (this._shouldSign && (wallet || signer || signers) && (this._transaction instanceof web3_js_1.Transaction || this._transaction instanceof web3_js_1.VersionedTransaction)) {
                if (wallet && this._transaction instanceof web3_js_1.Transaction) {
                    this._transaction = yield wallet.signTransaction(this._transaction);
                }
                else if (signer) {
                    if (this._transaction instanceof web3_js_1.Transaction) {
                        this._transaction.sign(signer);
                    }
                    else if (this._transaction instanceof web3_js_1.VersionedTransaction) {
                        this._transaction.sign([signer]);
                    }
                }
                else if (signers) {
                    for (const s of signers) {
                        if (this._transaction instanceof web3_js_1.Transaction) {
                            this._transaction.sign(s);
                        }
                        else if (this._transaction instanceof web3_js_1.VersionedTransaction) {
                            this._transaction.sign([s]);
                        }
                    }
                }
            }
            // send transaction
            let signatures = [];
            if (shouldRaceSend) {
                yield Promise.race(this._connections.map((conn) => __awaiter(this, void 0, void 0, function* () {
                    let signature = yield this.sendTransaction(skipPreflight, conn);
                    signatures.push(signature);
                })));
            }
            else {
                let signature = yield this.sendTransaction(skipPreflight, this._connections[0]);
                signatures.push(signature);
            }
            // confirm transaction if needed
            if (this._shouldConfirm && shouldConfirmOverride && signatures.length > 0 && shouldRaceSend === false) {
                yield Promise.all(signatures.map((sig) => __awaiter(this, void 0, void 0, function* () {
                    return yield this._connections[0].confirmTransaction(sig, confirmationCommitment || 'max');
                })));
            }
            else if (this._shouldConfirm && shouldConfirmOverride && signatures.length > 0 && shouldRaceSend) {
                yield Promise.all(this._connections.map((conn) => __awaiter(this, void 0, void 0, function* () {
                    return yield Promise.all(signatures.map((sig) => __awaiter(this, void 0, void 0, function* () {
                        return yield conn.confirmTransaction(sig, confirmationCommitment || 'max');
                    })));
                })));
            }
            return signatures;
        });
    }
    sendTransaction(skipPreflight, connection) {
        return __awaiter(this, void 0, void 0, function* () {
            connection = connection || this._connections[0];
            let signature;
            if (this._transaction instanceof web3_js_1.Transaction) {
                signature = yield this._connections[0].sendRawTransaction(this._transaction.serialize(), {
                    skipPreflight: skipPreflight || false
                });
            }
            else if (this._transaction instanceof web3_js_1.VersionedTransaction) {
                signature = yield this._connections[0].sendTransaction(this._transaction, { skipPreflight: skipPreflight || false });
            }
            else if (this._transaction instanceof Buffer) {
                signature = yield this._connections[0].sendRawTransaction(this._transaction, {
                    skipPreflight: skipPreflight || false
                });
            }
            else {
                throw new Error('Invalid transaction type');
            }
            return signature;
        });
    }
}
exports.SingleTransactionWrapper = SingleTransactionWrapper;
