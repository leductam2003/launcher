"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getJitoBundleStatus = exports.sendTransactionsAsBundleUsingJito = exports.sendTxUsingJito = exports.getJitoEndpoint = exports.JitoEndpoints = exports.TransactionWrapper = void 0;
const web3_js_1 = require("@solana/web3.js");
const Logger_1 = require("./Logger");
const bs58_1 = __importDefault(require("bs58"));
const node_fetch_1 = __importDefault(require("node-fetch"));
/**
 * TransactionWrapper is a utility class that simplifies the process of creating, signing, sending, and confirming transactions.
 */
class TransactionWrapper {
    constructor(connection, transaction, feePayer) {
        this._logger = new Logger_1.Logger('@soltoolkit/TransactionWrapper');
        this._transactions = transaction ? (Array.isArray(transaction) ? transaction : [transaction]) : [];
        this._connection = connection;
        this._feePayer = feePayer;
    }
    static create({ transaction, transactions, rpcEndpoint, connection, connectionManager, config, changeConn = false }) {
        var conn;
        if (connection) {
            conn = connection;
        }
        else if (rpcEndpoint) {
            conn = new web3_js_1.Connection(rpcEndpoint, config);
        }
        else if (connectionManager) {
            conn = connectionManager.connSync({ changeConn });
        }
        else {
            throw new Error('No connection or rpc endpoint provided');
        }
        return new TransactionWrapper(conn, transaction || transactions);
    }
    sendAndConfirm({ serialisedTx, maximumRetries = 5, commitment = 'max' }) {
        return __awaiter(this, void 0, void 0, function* () {
            var signature;
            var tries = 0;
            var isTransactionConfirmed = false;
            while (tries < maximumRetries && // not exceeded max retries
                !isTransactionConfirmed // no confirmation of any signature
            ) {
                try {
                    signature = yield this.sendTx({ serialisedTx });
                    const result = yield this.confirmTx({ signature, commitment });
                    if (result.value.err !== null) {
                        throw new Error(`RPC failure: ${JSON.stringify(result.value.err)}`);
                    }
                    this._logger.debug(result);
                    isTransactionConfirmed = true;
                }
                catch (e) {
                    if (e.message.includes('RPC failure')) {
                        throw e;
                    }
                    else {
                        this._logger.warn('Transaction failed, retrying...', e);
                        tries++;
                    }
                }
            }
            if (signature === undefined || !isTransactionConfirmed) {
                throw this._logger.makeError(`Transaction failed after ${tries} tries`);
            }
            return signature;
        });
    }
    addBlockhashAndFeePayer(feePayer) {
        return __awaiter(this, void 0, void 0, function* () {
            const latestBlockhash = yield this._connection.getLatestBlockhash();
            for (const transaction of this._transactions) {
                transaction.recentBlockhash = latestBlockhash.blockhash;
                transaction.feePayer = feePayer || this._feePayer;
                if (transaction.feePayer === undefined) {
                    throw new Error('Fee payer must be defined');
                }
                this._logger.debug('blockhash:', transaction.recentBlockhash);
                this._logger.debug('fee payer:', transaction.feePayer.toBase58());
            }
            return this;
        });
    }
    sign({ wallet, signers, txs }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!wallet && !signers) {
                throw new Error('No wallet or signers provided');
            }
            if (txs === undefined) {
                txs = this._transactions;
            }
            if (wallet) {
                var signedTx = yield wallet.signAllTransactions(txs);
                return signedTx;
            }
            else if (signers) {
                for (const signer of signers) {
                    for (const transaction of txs) {
                        transaction.sign(signer);
                    }
                }
                return txs;
            }
            else {
                throw new Error('Wallet or Signer must be provided');
            }
        });
    }
    sendTx({ serialisedTx }) {
        return __awaiter(this, void 0, void 0, function* () {
            var sig = yield this._connection.sendRawTransaction(serialisedTx);
            return sig;
        });
    }
    sendTxUsingJito({ serializedTx, region = 'mainnet' }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield sendTxUsingJito({ serializedTx, region });
        });
    }
    confirmTx({ signature, commitment = 'max' }) {
        return __awaiter(this, void 0, void 0, function* () {
            const latestBlockHash = yield this._connection.getLatestBlockhash(commitment);
            return yield this._connection.confirmTransaction({
                signature: signature,
                blockhash: latestBlockHash.blockhash,
                lastValidBlockHeight: latestBlockHash.lastValidBlockHeight
            }, commitment);
        });
    }
    static confirmTx({ connection, connectionManager, signature, commitment = 'max', changeConn = false, airdrop }) {
        return __awaiter(this, void 0, void 0, function* () {
            // if connection is not provided, use connection manager
            if (connection === undefined && connectionManager !== undefined) {
                connection = connectionManager.connSync({ changeConn, airdrop });
            }
            else if (connection === undefined && connectionManager === undefined) {
                throw new Error('No connection or connection manager provided');
            }
            if (connection === undefined) {
                throw new Error('Connection is undefined');
            }
            const latestBlockHash = yield connection.getLatestBlockhash(commitment);
            return yield connection.confirmTransaction({
                signature: signature,
                blockhash: latestBlockHash.blockhash,
                lastValidBlockHeight: latestBlockHash.lastValidBlockHeight
            }, commitment);
        });
    }
}
exports.TransactionWrapper = TransactionWrapper;
exports.JitoEndpoints = {
    mainnet: 'https://mainnet.block-engine.jito.wtf/api/v1/',
    amsterdam: 'https://amsterdam.mainnet.block-engine.jito.wtf/api/v1/',
    frankfurt: 'https://frankfurt.mainnet.block-engine.jito.wtf/api/v1/',
    ny: 'https://ny.mainnet.block-engine.jito.wtf/api/v1/',
    tokyo: 'https://tokyo.mainnet.block-engine.jito.wtf/api/v1/'
};
function getJitoEndpoint(region) {
    return exports.JitoEndpoints[region];
}
exports.getJitoEndpoint = getJitoEndpoint;
/**
 * Send a transaction using Jito. This only supports sending a single transaction on mainnet only.
 * See https://jito-labs.gitbook.io/mev/searcher-resources/json-rpc-api-reference/transactions-endpoint/sendtransaction.
 * @param args.serialisedTx - A single transaction to be sent, in serialised form
 * @param args.region - The region of the Jito endpoint to use
 * @returns The signature of the transaction
 */
function sendTxUsingJito({ serializedTx, region = 'mainnet' }) {
    return __awaiter(this, void 0, void 0, function* () {
        let rpcEndpoint = getJitoEndpoint(region);
        let encodedTx = bs58_1.default.encode(serializedTx);
        let payload = {
            jsonrpc: '2.0',
            id: 1,
            method: 'sendTransaction',
            params: [encodedTx]
        };
        let res = yield (0, node_fetch_1.default)(`${rpcEndpoint}transactions`, {
            method: 'POST',
            body: JSON.stringify(payload),
            headers: { 'Content-Type': 'application/json' }
        });
        let json = yield res.json();
        if (json.error) {
            throw new Error(json.error.message);
        }
        return json.result;
    });
}
exports.sendTxUsingJito = sendTxUsingJito;
/**
 * Send a bundle of transactions using Jito.
 * @param param0.signedTxs - An array of signed transactions
 * @param param0.region - The region of the Jito endpoint to use. Defaults to mainnet.
 * @returns A bundle ID, used to identify the bundle. This is the SHA-256 hash of the bundle's transaction signatures.
 */
function sendTransactionsAsBundleUsingJito({ signedTxs, region = 'mainnet' }) {
    return __awaiter(this, void 0, void 0, function* () {
        // Get the endpoint for the region
        let rpcEndpoint = getJitoEndpoint(region);
        // Encode the transactions
        let encodedTxs = signedTxs.map((tx) => bs58_1.default.encode(tx.serialize({
            // Skip signature verification
            verifySignatures: true
        })));
        // Send bundle
        let payload = {
            jsonrpc: '2.0',
            id: 1,
            method: 'sendBundle',
            params: [encodedTxs]
        };
        let res = yield (0, node_fetch_1.default)(`${rpcEndpoint}/bundles`, {
            method: 'POST',
            body: JSON.stringify(payload),
            headers: { 'Content-Type': 'application/json' }
        });
        // Parse response and return bundle ID
        let json = yield res.json();
        if (json.error) {
            throw new Error(json.error.message);
        }
        return json.result;
    });
}
exports.sendTransactionsAsBundleUsingJito = sendTransactionsAsBundleUsingJito;
/**
 * Get the status of a bundle using Jito.
 * @param param0.bundleId - The bundle ID to get the status of.
 * @returns The status of the bundle, or null if the bundle does not exist.
 */
function getJitoBundleStatus({ bundleId, region = 'mainnet' }) {
    return __awaiter(this, void 0, void 0, function* () {
        // Get the endpoint for the region
        let rpcEndpoint = getJitoEndpoint(region);
        // Send bundle status request
        let payload = {
            jsonrpc: '2.0',
            id: 1,
            method: 'getBundleStatuses',
            params: [[bundleId]]
        };
        let res = yield (0, node_fetch_1.default)(`${rpcEndpoint}/bundles`, {
            method: 'POST',
            body: JSON.stringify(payload),
            headers: { 'Content-Type': 'application/json' }
        });
        // Parse response
        let json = yield res.json();
        if (json === null) {
            return null;
        }
        if (json.error) {
            throw new Error(json.error.message);
        }
        return json.result.value;
    });
}
exports.getJitoBundleStatus = getJitoBundleStatus;
