/// <reference types="node" />
import { Transaction, Connection, PublicKey, ConnectionConfig, Commitment, Signer } from '@solana/web3.js';
import { IWallet } from '../interfaces/IWallet';
import { ConnectionManager } from './ConnectionManager';
/**
 * TransactionWrapper is a utility class that simplifies the process of creating, signing, sending, and confirming transactions.
 */
export declare class TransactionWrapper {
    private _transactions;
    private _connection;
    private _logger;
    private _feePayer?;
    private constructor();
    static create({ transaction, transactions, rpcEndpoint, connection, connectionManager, config, changeConn }: {
        transaction?: Transaction;
        transactions?: Transaction[];
        rpcEndpoint?: string;
        connection?: Connection;
        connectionManager?: ConnectionManager;
        signer?: PublicKey;
        config?: ConnectionConfig;
        changeConn?: boolean;
    }): TransactionWrapper;
    sendAndConfirm({ serialisedTx, maximumRetries, commitment }: {
        serialisedTx: Uint8Array | Buffer | number[];
        maximumRetries?: number;
        commitment?: Commitment;
    }): Promise<string>;
    addBlockhashAndFeePayer(feePayer?: PublicKey): Promise<this>;
    sign({ wallet, signers, txs }: {
        wallet?: IWallet;
        signers?: Signer[];
        txs?: Transaction[];
    }): Promise<Transaction[]>;
    sendTx({ serialisedTx }: {
        serialisedTx: Uint8Array | Buffer | number[];
    }): Promise<string>;
    sendTxUsingJito({ serializedTx, region }: {
        serializedTx: Uint8Array | Buffer | number[];
        region: JitoRegion;
    }): Promise<string>;
    confirmTx({ signature, commitment }: {
        signature: string;
        commitment?: Commitment;
    }): Promise<import("@solana/web3.js").RpcResponseAndContext<import("@solana/web3.js").SignatureResult>>;
    static confirmTx({ connection, connectionManager, signature, commitment, changeConn, airdrop }: {
        connection?: Connection;
        connectionManager?: ConnectionManager;
        signature: string;
        commitment?: Commitment;
        changeConn?: boolean;
        airdrop?: boolean;
    }): Promise<import("@solana/web3.js").RpcResponseAndContext<import("@solana/web3.js").SignatureResult>>;
}
export type JitoRegion = 'mainnet' | 'amsterdam' | 'frankfurt' | 'ny' | 'tokyo';
export declare const JitoEndpoints: {
    mainnet: string;
    amsterdam: string;
    frankfurt: string;
    ny: string;
    tokyo: string;
};
interface BundleStatusResult {
    bundle_id: string;
    transactions: string[];
    slot: number;
    confirmation_status: string;
    err?: any;
}
export declare function getJitoEndpoint(region: JitoRegion): string;
/**
 * Send a transaction using Jito. This only supports sending a single transaction on mainnet only.
 * See https://jito-labs.gitbook.io/mev/searcher-resources/json-rpc-api-reference/transactions-endpoint/sendtransaction.
 * @param args.serialisedTx - A single transaction to be sent, in serialised form
 * @param args.region - The region of the Jito endpoint to use
 * @returns The signature of the transaction
 */
export declare function sendTxUsingJito({ serializedTx, region }: {
    serializedTx: Uint8Array | Buffer | number[];
    region?: JitoRegion;
}): Promise<string>;
/**
 * Send a bundle of transactions using Jito.
 * @param param0.signedTxs - An array of signed transactions
 * @param param0.region - The region of the Jito endpoint to use. Defaults to mainnet.
 * @returns A bundle ID, used to identify the bundle. This is the SHA-256 hash of the bundle's transaction signatures.
 */
export declare function sendTransactionsAsBundleUsingJito({ signedTxs, region }: {
    signedTxs: Transaction[];
    region?: JitoRegion;
}): Promise<string>;
/**
 * Get the status of a bundle using Jito.
 * @param param0.bundleId - The bundle ID to get the status of.
 * @returns The status of the bundle, or null if the bundle does not exist.
 */
export declare function getJitoBundleStatus({ bundleId, region }: {
    bundleId: string;
    region?: JitoRegion;
}): Promise<BundleStatusResult[] | null>;
export {};
